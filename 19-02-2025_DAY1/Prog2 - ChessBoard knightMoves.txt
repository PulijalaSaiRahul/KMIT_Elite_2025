Mr Suleman is given a checkerboard of size 400*400, where the indices starts 
from (-200,-200) and ends at (199,199). In one step, he can move the box from 
position (p,q) to one of the following positions in L shape like as follows: 
	- (p-2, q-1), (p-2, q+1), (p+2, q-1), (p+2, q+1)
	- (p-1, q+2), (p+1, q+2), (p-1, q-2), (p+1, q-2)

Initially the box is at (0,0) position, and need to move the box to position (m,n).
You will be given two integers m and n indicates the position(m,n).

Now your task is to help by Mr Suleman to find the minimum number of steps 
required to move the box from (0,0) to (m,n).

Note: It is allowed to move out of the board also.

Input Format:
-----------------
Two space separated integers, m and n, position.

Output Format:
------------------
Print an integer, minimum number of steps to reach (m,n).


Sample Input-1:
---------------
2 4

Sample Output-1:
----------------
2

Explanation:
-------------
Initially, you are at (0,0) position, you can reach (2,4) as follows:
(0,0) -> (1, 2) -> (2, 4) 


Sample Input-2:
---------------
4 7

Sample Output-2:
----------------
5

Explanation:
------------
Initially, you are at (0,0) position, you can reach (4,7) as follows:
(0,0) -> (1, 2) -> (2, 4) -> (1, 6) -> (3, 5) -> (4, 7)

Solution
#include<bits/stdc++.h>
using namespace std;
vector<vector<int>> dir{{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{-2,1},{2,-1},{-2,-1}};
int BFS(int m,int n){
    auto isSafe=[&](int u,int v){
        return u>=-200 && v<200 && u<200 && v>=-200;
    };
    
    vector<vector<int>> visited(400,vector<int>(400,false));
    queue<pair<int,int>> q;
    q.push({0,0});
    visited[0][0]=true;
    
    int steps=0;
    while(!q.empty()){
        int s=q.size();
        while(s--){
            auto curr=q.front();
            q.pop();
            
            int x=curr.first;
            int y=curr.second;
            
            // cout<<x<<"--"<<y<<endl;
            
            if(x==m && y==n)
                return steps;
            
            for(auto d:dir){
                int nx=x+d[0];
                int ny=y+d[1];
                
                if(isSafe(nx,ny) && !visited[nx+200][ny+200]){
                    q.push({nx,ny});
                    visited[nx+200][ny+200]=true;
                }
            }
        }
        steps++;
    }
    return 0;
}
int main(){
    int m,n;
    cin>>m>>n;
    
    cout<<BFS(m,n);
    return 0;
}
